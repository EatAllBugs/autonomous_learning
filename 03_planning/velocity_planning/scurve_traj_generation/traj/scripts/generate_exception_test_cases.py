#!/usr/bin/env python
''' python script to auto-generate test-cases to test the "traj.fit_traj_segment" function.
    this file rejects all the feasible cases that can fit into one segment, 
    and it generates the cases that should raise an error inside the function!
    So, this files to test that the function can identify illogical/unfeasible cases and raise an error 
'''

import random 
import os
import stat
import traj 

def generate_exception_test_cases(num_of_cases, p_max_abs, v_max_abs, a_max_abs, j_max_abs, fixed_limit):
    test_auto_generated_cases  = os.getcwd() +"/test_autogenerated_exception_cases.py"
    plot_random_cases  = os.getcwd() +"/plot_autogenerated_exception_test_cases.py"

    with open(test_auto_generated_cases, 'w') as random_cases:
        with open(plot_random_cases, 'w') as plot_segment:
            print >> random_cases, '''
#this is an auto-generated test file, generated using python script: generate_exception_test_cases -->    
import nose
import numpy as np
import random 
import traj

'''
            print >> plot_segment, '''#!/usr/bin/env python
#this is an auto-generated test file, generated using python script: generate_exception_test_cases -->    
import traj
'''
            ## assign the limits if it is fixed_limits case 
            p_max = p_max_abs
            v_max = v_max_abs
            a_max = a_max_abs
            j_max = j_max_abs    
            

            case = 0
            while case < num_of_cases:
                add_case = False
                violate_pmax= False
                
                # random limits option: fixed_limit= False
                if not fixed_limit: 
                    p_max = random.uniform(0.1, p_max_abs)
                    v_max = random.uniform(0.1, v_max_abs)
                    a_max = random.uniform(0.1, j_max_abs)
                    j_max = random.uniform(0.1, a_max_abs)
                    
               
               ############## choose random start/stop pos/vel within the limits (given or random generated limits)    
                p_start = random.uniform(-p_max, p_max)
                p_end   = random.uniform(-p_max, p_max)
                v_start = random.uniform(-v_max, v_max)
                v_end   = random.uniform(-v_max, v_max)
                
                
                
                ############## 1] check cases when pos_diff less than the min pos_diff to reach v_end from v_start               
                if(v_start*v_end>0):
                    abs_minPos_to_vf, acc_to_vf, t_jrk_to_vf, t_acc_to_vf = traj.calculate_min_pos_reached_acc_jrk_time_acc_time_to_reach_final_vel(abs(v_start), abs(v_end), v_max, a_max, j_max)
                    if abs_minPos_to_vf > abs(p_end-p_start):
                        add_case = True                        
                        ###print the test statement for this case in the testing generated script
                        print>> random_cases, '''
def test_exception_{}():
    with nose.tools.assert_raises_regexp(ValueError, "non feasible case: violate min_pos_to_vf"):
        position, velocity, jerk, acceleration = traj.fit_traj_segment({}, {}, {}, {},  {}, {}, {}, {})
'''.format(case, p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max  )              


             
                ############## 2] check cases when combination of: motion & pos_diff requires that position violate p_max               
                if(v_start*v_end<0):                
                    minPos_to_zero, acc_to_zero, t_jrk_to_zero, t_acc_to_zero = traj.calculate_min_pos_reached_acc_jrk_time_acc_time_to_reach_final_vel(v_start,   0.0,   v_max, a_max, j_max)
                    minPos_to_vf, acc_to_vf, t_jrk_to_vf, t_acc_to_vf         = traj.calculate_min_pos_reached_acc_jrk_time_acc_time_to_reach_final_vel(    0.0, v_end,   v_max, a_max, j_max) 
                    pos_diff = p_end - p_start
                    pos_dominant = pos_diff - minPos_to_zero - minPos_to_vf    
                
                    ######## A) complex positive motion case ########################
                    if pos_dominant > 0:  ## positive dominant case       
                        if v_start < 0 and v_end > 0: # from negative to positive 
                            if abs(p_start+minPos_to_zero) > p_max or abs(p_start+minPos_to_zero+minPos_to_vf) > p_max or  abs(p_start+minPos_to_zero+minPos_to_vf+pos_dominant) > p_max:
                                add_case = True
                                violate_pmax=True
                        elif v_start > 0 and v_end < 0: #from positive to negative
                            if abs(p_start+pos_dominant) > p_max or abs(p_start+pos_dominant+minPos_to_zero) > p_max or  abs(p_start+pos_dominant+minPos_to_zero+minPos_to_vf) > p_max:
                                add_case = True
                                violate_pmax=True
                            
                    ######## B) complex negative motion case ########################
                    if pos_dominant < 0:  ## negative dominant case 
                        if v_start < 0 and v_end > 0: # from negative to positive
                            if abs(p_start+pos_dominant) > p_max or abs(p_start+pos_dominant+minPos_to_zero) > p_max or  abs(p_start+pos_dominant+minPos_to_zero+minPos_to_vf) > p_max:
                                add_case = True
                                violate_pmax=True
                        elif v_start > 0 and v_end < 0: #from positive to negative
                            if abs(p_start+minPos_to_zero) > p_max or abs(p_start+minPos_to_zero+minPos_to_vf) > p_max or  abs(p_start+minPos_to_zero+minPos_to_vf+pos_dominant) > p_max:
                                add_case = True
                                violate_pmax=True
                
                     
                 
                ############## 3] check cases when motion direction is opposit pos_diff direction
                if (v_start>0 and v_end>0 and (p_end-p_start)<0) or (v_start<0 and v_end<0 and (p_end-p_start)>0): # +ve motion vs -ve pos_diff or -ve motion vs +ve pos_diff
                    add_case = True
                    ###print the test statement for this case in the testing generated script
                    print>> random_cases, '''
def test_exception_{}():
    with nose.tools.assert_raises_regexp(ValueError, "non feasible case: vel_motion opposite to pos_motion"):
        position, velocity, jerk, acceleration = traj.fit_traj_segment({}, {}, {}, {},  {}, {}, {}, {})
'''.format(case, p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max  )                     
                    
                    
                ############## add plotting statement  ##############
                if violate_pmax:           
                    ###print the test statement for this case in the testing generated script
                    print>> random_cases, '''
def test_exception_{}():
    with nose.tools.assert_raises_regexp(ValueError, "non feasible case: violate p_max"):
        position, velocity, jerk, acceleration = traj.fit_traj_segment({}, {}, {}, {},  {}, {}, {}, {})
'''.format(case, p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max  )   



                ############## add plotting statement  ##############
                if add_case:
                    case +=1             
                    ###print the plot statement for this case in the plotting generated script
                    print>> plot_segment, '''#case_{}
traj.traj_plot.fit_and_plot_segment({}, {}, {}, {}, {}, {}, {}, {})
'''.format( case, p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max )
    
                
                
                
    st = os.stat(test_auto_generated_cases)
    os.chmod(test_auto_generated_cases, st.st_mode | stat.S_IEXEC)
    st = os.stat(plot_random_cases)
    os.chmod(plot_random_cases, st.st_mode | stat.S_IEXEC)

            
            
            
   
##### generate random cases
num_of_cases = 1000

## random cases with fixed limits 
p_max = 5.0
v_max = 2.0
a_max = 3.0
j_max = 1.0      

## random cases with variable limits: [the sollowing are limits for the limits]
p_max = 10.0
v_max = 10.0
a_max = 10.0
j_max = 10.0   

fixed_limit = False 
generate_exception_test_cases(num_of_cases, p_max, v_max, a_max, j_max, fixed_limit)       
    
        


        